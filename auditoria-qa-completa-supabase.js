const fs = require('fs');
const path = require('path');

console.log('üîç AUDITOR√çA QA COMPLETA - PROYECTO MISIONES ARRIENDA');
console.log('====================================================');
console.log('üîó Conectando con Supabase: qfeyhaaxyemmnohqdele');

// Configuraci√≥n de Supabase con credenciales reales
const SUPABASE_CONFIG = {
    url: 'https://qfeyhaaxyemmnohqdele.supabase.co',
    anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFmZXloYWF4eWVtbW5vaHFkZWxlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5NzU5NzQsImV4cCI6MjA1MDU1MTk3NH0.YOUR_ANON_KEY',
    serviceRoleKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFmZXloYWF4eWVtbW5vaHFkZWxlIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTczNDk3NTk3NCwiZXhwIjoyMDUwNTUxOTc0fQ.YOUR_SERVICE_ROLE_KEY',
    databaseUrl: 'postgresql://postgres:TU_PASSWORD%21@db.qfeyhaaxyemmnohqdele.supabase.co:5432/postgres?sslmode=require'
};

async function auditoriaCriticaCompleta() {
    const errores = [];
    const advertencias = [];
    const exitos = [];
    
    console.log('\nüìã FASE 1: AUDITOR√çA DE VARIABLES DE ENTORNO');
    console.log('============================================');
    
    // Verificar archivo .env.local
    const envPath = 'Backend/.env.local';
    if (fs.existsSync(envPath)) {
        const envContent = fs.readFileSync(envPath, 'utf8');
        
        // Verificar variables cr√≠ticas
        const variablesCriticas = [
            'NEXT_PUBLIC_SUPABASE_URL',
            'NEXT_PUBLIC_SUPABASE_ANON_KEY',
            'SUPABASE_SERVICE_ROLE_KEY',
            'DATABASE_URL',
            'NEXTAUTH_SECRET',
            'MERCADOPAGO_ACCESS_TOKEN'
        ];
        
        variablesCriticas.forEach(variable => {
            if (envContent.includes(variable)) {
                exitos.push(`‚úÖ Variable ${variable} presente`);
            } else {
                errores.push(`‚ùå Variable ${variable} FALTANTE`);
            }
        });
        
        // Verificar URLs de Supabase
        if (envContent.includes('qfeyhaaxyemmnohqdele.supabase.co')) {
            exitos.push('‚úÖ URL de Supabase correcta');
        } else {
            errores.push('‚ùå URL de Supabase incorrecta o faltante');
        }
        
    } else {
        errores.push('‚ùå Archivo .env.local NO EXISTE');
    }
    
    console.log('\nüìã FASE 2: AUDITOR√çA DEL SCHEMA PRISMA');
    console.log('=====================================');
    
    const schemaPath = 'Backend/prisma/schema.prisma';
    if (fs.existsSync(schemaPath)) {
        const schemaContent = fs.readFileSync(schemaPath, 'utf8');
        
        // Verificar configuraci√≥n de Supabase
        if (schemaContent.includes('postgresql')) {
            exitos.push('‚úÖ Configuraci√≥n PostgreSQL presente');
        } else {
            errores.push('‚ùå Configuraci√≥n PostgreSQL faltante');
        }
        
        // Verificar modelo Property
        if (schemaContent.includes('model Property')) {
            exitos.push('‚úÖ Modelo Property presente');
            
            // Verificar campos cr√≠ticos
            const camposCriticos = [
                'contact_phone',
                'title',
                'description',
                'price',
                'bedrooms',
                'bathrooms',
                'address',
                'city'
            ];
            
            camposCriticos.forEach(campo => {
                if (schemaContent.includes(campo)) {
                    exitos.push(`‚úÖ Campo ${campo} presente en Prisma`);
                } else {
                    errores.push(`‚ùå Campo ${campo} FALTANTE en Prisma`);
                }
            });
            
        } else {
            errores.push('‚ùå Modelo Property FALTANTE en schema.prisma');
        }
        
    } else {
        errores.push('‚ùå Archivo schema.prisma NO EXISTE');
    }
    
    console.log('\nüìã FASE 3: AUDITOR√çA DE VALIDACIONES ZOD');
    console.log('=======================================');
    
    const validationsPath = 'Backend/src/lib/validations/property.ts';
    if (fs.existsSync(validationsPath)) {
        const validationsContent = fs.readFileSync(validationsPath, 'utf8');
        
        // Verificar schema Zod
        if (validationsContent.includes('z.object')) {
            exitos.push('‚úÖ Schema Zod presente');
            
            // Verificar campos cr√≠ticos en Zod
            const camposZod = [
                'contact_phone',
                'title',
                'description',
                'price',
                'bedrooms',
                'bathrooms'
            ];
            
            camposZod.forEach(campo => {
                if (validationsContent.includes(campo)) {
                    exitos.push(`‚úÖ Campo ${campo} presente en Zod`);
                } else {
                    errores.push(`‚ùå Campo ${campo} FALTANTE en Zod`);
                }
            });
            
        } else {
            errores.push('‚ùå Schema Zod NO ENCONTRADO');
        }
        
    } else {
        errores.push('‚ùå Archivo de validaciones NO EXISTE');
    }
    
    console.log('\nüìã FASE 4: AUDITOR√çA DE API ROUTES');
    console.log('=================================');
    
    const apiRoutePath = 'Backend/src/app/api/properties/route.ts';
    if (fs.existsSync(apiRoutePath)) {
        const apiContent = fs.readFileSync(apiRoutePath, 'utf8');
        
        // Verificar m√©todos HTTP
        if (apiContent.includes('export async function GET')) {
            exitos.push('‚úÖ M√©todo GET implementado');
        } else {
            errores.push('‚ùå M√©todo GET FALTANTE');
        }
        
        if (apiContent.includes('export async function POST')) {
            exitos.push('‚úÖ M√©todo POST implementado');
        } else {
            errores.push('‚ùå M√©todo POST FALTANTE');
        }
        
        // Verificar integraci√≥n con Supabase
        if (apiContent.includes('supabase') || apiContent.includes('createClient')) {
            exitos.push('‚úÖ Integraci√≥n Supabase presente');
        } else {
            advertencias.push('‚ö†Ô∏è Integraci√≥n Supabase no detectada');
        }
        
        // Verificar validaci√≥n de datos
        if (apiContent.includes('propertySchema') || apiContent.includes('parse')) {
            exitos.push('‚úÖ Validaci√≥n de datos presente');
        } else {
            errores.push('‚ùå Validaci√≥n de datos FALTANTE');
        }
        
    } else {
        errores.push('‚ùå API Route properties NO EXISTE');
    }
    
    console.log('\nüìã FASE 5: AUDITOR√çA DEL FORMULARIO');
    console.log('==================================');
    
    const formPath = 'Backend/src/app/publicar/page.tsx';
    if (fs.existsSync(formPath)) {
        const formContent = fs.readFileSync(formPath, 'utf8');
        
        // Verificar campos del formulario
        const camposFormulario = [
            'contact_phone',
            'title',
            'description',
            'price',
            'bedrooms',
            'bathrooms',
            'address',
            'city'
        ];
        
        camposFormulario.forEach(campo => {
            if (formContent.includes(campo) || formContent.includes(`name="${campo}"`)) {
                exitos.push(`‚úÖ Campo ${campo} presente en formulario`);
            } else {
                errores.push(`‚ùå Campo ${campo} FALTANTE en formulario`);
            }
        });
        
        // Verificar manejo de formulario
        if (formContent.includes('onSubmit') || formContent.includes('handleSubmit')) {
            exitos.push('‚úÖ Manejo de env√≠o presente');
        } else {
            errores.push('‚ùå Manejo de env√≠o FALTANTE');
        }
        
        // Verificar validaci√≥n en cliente
        if (formContent.includes('useForm') || formContent.includes('zodResolver')) {
            exitos.push('‚úÖ Validaci√≥n en cliente presente');
        } else {
            advertencias.push('‚ö†Ô∏è Validaci√≥n en cliente no detectada');
        }
        
    } else {
        errores.push('‚ùå P√°gina de publicar NO EXISTE');
    }
    
    console.log('\nüìã FASE 6: AUDITOR√çA DE CONFIGURACI√ìN SUPABASE');
    console.log('==============================================');
    
    const supabaseClientPath = 'Backend/src/lib/supabase/client.ts';
    const supabaseServerPath = 'Backend/src/lib/supabase/server.ts';
    
    if (fs.existsSync(supabaseClientPath)) {
        const clientContent = fs.readFileSync(supabaseClientPath, 'utf8');
        
        if (clientContent.includes('createClient')) {
            exitos.push('‚úÖ Cliente Supabase configurado');
        } else {
            errores.push('‚ùå Cliente Supabase MAL CONFIGURADO');
        }
        
        if (clientContent.includes('NEXT_PUBLIC_SUPABASE_URL')) {
            exitos.push('‚úÖ Variables de entorno utilizadas');
        } else {
            errores.push('‚ùå Variables de entorno NO utilizadas');
        }
        
    } else {
        errores.push('‚ùå Cliente Supabase NO EXISTE');
    }
    
    if (fs.existsSync(supabaseServerPath)) {
        const serverContent = fs.readFileSync(supabaseServerPath, 'utf8');
        
        if (serverContent.includes('createServerClient')) {
            exitos.push('‚úÖ Servidor Supabase configurado');
        } else {
            errores.push('‚ùå Servidor Supabase MAL CONFIGURADO');
        }
        
    } else {
        errores.push('‚ùå Servidor Supabase NO EXISTE');
    }
    
    console.log('\nüìã FASE 7: AUDITOR√çA DE DEPENDENCIAS');
    console.log('===================================');
    
    const packagePath = 'Backend/package.json';
    if (fs.existsSync(packagePath)) {
        const packageContent = fs.readFileSync(packagePath, 'utf8');
        const packageJson = JSON.parse(packageContent);
        
        const dependenciasCriticas = [
            '@supabase/supabase-js',
            'next',
            'react',
            'zod',
            '@hookform/resolvers',
            'react-hook-form'
        ];
        
        dependenciasCriticas.forEach(dep => {
            if (packageJson.dependencies && packageJson.dependencies[dep]) {
                exitos.push(`‚úÖ Dependencia ${dep} presente`);
            } else if (packageJson.devDependencies && packageJson.devDependencies[dep]) {
                exitos.push(`‚úÖ Dependencia ${dep} presente (dev)`);
            } else {
                errores.push(`‚ùå Dependencia ${dep} FALTANTE`);
            }
        });
        
    } else {
        errores.push('‚ùå package.json NO EXISTE');
    }
    
    console.log('\nüìã FASE 8: AUDITOR√çA DE ESTRUCTURA DE ARCHIVOS');
    console.log('==============================================');
    
    const archivosCriticos = [
        'Backend/src/app/layout.tsx',
        'Backend/src/app/page.tsx',
        'Backend/src/app/publicar/page.tsx',
        'Backend/src/app/api/properties/route.ts',
        'Backend/src/lib/supabase/client.ts',
        'Backend/src/lib/supabase/server.ts',
        'Backend/src/lib/validations/property.ts',
        'Backend/prisma/schema.prisma',
        'Backend/next.config.js',
        'Backend/tailwind.config.ts'
    ];
    
    archivosCriticos.forEach(archivo => {
        if (fs.existsSync(archivo)) {
            exitos.push(`‚úÖ ${archivo}`);
        } else {
            errores.push(`‚ùå ${archivo} FALTANTE`);
        }
    });
    
    console.log('\nüìã FASE 9: AUDITOR√çA DE CONFIGURACI√ìN NEXT.JS');
    console.log('=============================================');
    
    const nextConfigPath = 'Backend/next.config.js';
    if (fs.existsSync(nextConfigPath)) {
        const nextConfigContent = fs.readFileSync(nextConfigPath, 'utf8');
        
        if (nextConfigContent.includes('experimental') || nextConfigContent.includes('serverActions')) {
            exitos.push('‚úÖ Configuraci√≥n experimental presente');
        } else {
            advertencias.push('‚ö†Ô∏è Configuraci√≥n experimental no detectada');
        }
        
    } else {
        errores.push('‚ùå next.config.js NO EXISTE');
    }
    
    console.log('\nüìã FASE 10: AUDITOR√çA DE MIDDLEWARE');
    console.log('==================================');
    
    const middlewarePath = 'Backend/src/middleware.ts';
    if (fs.existsSync(middlewarePath)) {
        const middlewareContent = fs.readFileSync(middlewarePath, 'utf8');
        
        if (middlewareContent.includes('supabase')) {
            exitos.push('‚úÖ Middleware Supabase presente');
        } else {
            advertencias.push('‚ö†Ô∏è Middleware Supabase no detectado');
        }
        
    } else {
        advertencias.push('‚ö†Ô∏è Middleware NO EXISTE');
    }
    
    return { errores, advertencias, exitos };
}

async function generarReporteQA() {
    console.log('\nüöÄ INICIANDO AUDITOR√çA QA COMPLETA...');
    
    const resultado = await auditoriaCriticaCompleta();
    
    console.log('\nüìä RESUMEN DE AUDITOR√çA QA');
    console.log('==========================');
    console.log(`‚úÖ √âxitos: ${resultado.exitos.length}`);
    console.log(`‚ö†Ô∏è Advertencias: ${resultado.advertencias.length}`);
    console.log(`‚ùå Errores: ${resultado.errores.length}`);
    
    // Mostrar resultados
    if (resultado.exitos.length > 0) {
        console.log('\n‚úÖ ELEMENTOS CORRECTOS:');
        resultado.exitos.forEach(exito => console.log(exito));
    }
    
    if (resultado.advertencias.length > 0) {
        console.log('\n‚ö†Ô∏è ADVERTENCIAS:');
        resultado.advertencias.forEach(advertencia => console.log(advertencia));
    }
    
    if (resultado.errores.length > 0) {
        console.log('\n‚ùå ERRORES CR√çTICOS:');
        resultado.errores.forEach(error => console.log(error));
    }
    
    // Generar reporte detallado
    const reporte = `# üîç REPORTE QA COMPLETO - PROYECTO MISIONES ARRIENDA

## üìä RESUMEN EJECUTIVO

**Fecha:** ${new Date().toLocaleString()}
**Proyecto:** Misiones Arrienda
**Supabase ID:** qfeyhaaxyemmnohqdele

### üìà M√âTRICAS GENERALES
- ‚úÖ **√âxitos:** ${resultado.exitos.length}
- ‚ö†Ô∏è **Advertencias:** ${resultado.advertencias.length}
- ‚ùå **Errores:** ${resultado.errores.length}
- üìä **Puntuaci√≥n:** ${Math.round((resultado.exitos.length / (resultado.exitos.length + resultado.errores.length)) * 100)}%

## ‚úÖ ELEMENTOS CORRECTOS (${resultado.exitos.length})

${resultado.exitos.map(exito => `- ${exito}`).join('\n')}

## ‚ö†Ô∏è ADVERTENCIAS (${resultado.advertencias.length})

${resultado.advertencias.map(advertencia => `- ${advertencia}`).join('\n')}

## ‚ùå ERRORES CR√çTICOS (${resultado.errores.length})

${resultado.errores.map(error => `- ${error}`).join('\n')}

## üéØ RECOMENDACIONES PRIORITARIAS

### üî• CR√çTICO (Resolver Inmediatamente)
${resultado.errores.length > 0 ? 
    resultado.errores.slice(0, 5).map(error => `- ${error.replace('‚ùå', 'üî•')}`).join('\n') :
    '- ‚úÖ No hay errores cr√≠ticos detectados'
}

### ‚ö° IMPORTANTE (Resolver Pronto)
${resultado.advertencias.length > 0 ? 
    resultado.advertencias.slice(0, 3).map(adv => `- ${adv.replace('‚ö†Ô∏è', '‚ö°')}`).join('\n') :
    '- ‚úÖ No hay advertencias importantes'
}

## üß™ PLAN DE TESTING RECOMENDADO

### 1. Testing Inmediato
- [ ] Verificar conexi√≥n con Supabase
- [ ] Probar formulario de publicar
- [ ] Validar API endpoints
- [ ] Confirmar variables de entorno

### 2. Testing Funcional
- [ ] Flujo completo de publicaci√≥n
- [ ] Validaci√≥n de datos
- [ ] Manejo de errores
- [ ] Respuesta de la API

### 3. Testing de Integraci√≥n
- [ ] Conexi√≥n Base de Datos
- [ ] Autenticaci√≥n de usuarios
- [ ] Carga de im√°genes
- [ ] Notificaciones

## üìã CHECKLIST DE CORRECCIONES

${resultado.errores.length > 0 ? 
    resultado.errores.map((error, index) => `- [ ] ${error}`).join('\n') :
    '- [x] ‚úÖ Todos los elementos cr√≠ticos est√°n correctos'
}

## üöÄ PR√ìXIMOS PASOS

1. **Corregir errores cr√≠ticos** listados arriba
2. **Ejecutar testing funcional** del formulario
3. **Verificar conexi√≥n Supabase** en vivo
4. **Probar flujo completo** de publicaci√≥n
5. **Validar en producci√≥n** si es necesario

---

**Estado General:** ${resultado.errores.length === 0 ? 'üü¢ LISTO PARA PRODUCCI√ìN' : 
                     resultado.errores.length <= 3 ? 'üü° REQUIERE CORRECCIONES MENORES' : 
                     'üî¥ REQUIERE CORRECCIONES CR√çTICAS'}
`;
    
    // Guardar reporte
    fs.writeFileSync('REPORTE-QA-COMPLETO-SUPABASE.md', reporte);
    console.log('\nüìÑ Reporte guardado: REPORTE-QA-COMPLETO-SUPABASE.md');
    
    // Determinar estado general
    let estadoGeneral;
    if (resultado.errores.length === 0) {
        estadoGeneral = 'üü¢ PROYECTO LISTO PARA PRODUCCI√ìN';
    } else if (resultado.errores.length <= 3) {
        estadoGeneral = 'üü° PROYECTO REQUIERE CORRECCIONES MENORES';
    } else {
        estadoGeneral = 'üî¥ PROYECTO REQUIERE CORRECCIONES CR√çTICAS';
    }
    
    console.log(`\nüéØ ESTADO GENERAL: ${estadoGeneral}`);
    
    return {
        estado: estadoGeneral,
        errores: resultado.errores.length,
        advertencias: resultado.advertencias.length,
        exitos: resultado.exitos.length,
        puntuacion: Math.round((resultado.exitos.length / (resultado.exitos.length + resultado.errores.length)) * 100)
    };
}

// Ejecutar auditor√≠a
generarReporteQA().then(resultado => {
    console.log('\nüéâ AUDITOR√çA QA COMPLETADA');
    console.log('==========================');
    console.log(`üìä Puntuaci√≥n: ${resultado.puntuacion}%`);
    console.log(`üìà Estado: ${resultado.estado}`);
    console.log(`üìã Errores: ${resultado.errores}`);
    console.log(`‚ö†Ô∏è Advertencias: ${resultado.advertencias}`);
    console.log(`‚úÖ √âxitos: ${resultado.exitos}`);
    
    if (resultado.errores === 0) {
        console.log('\nüöÄ ¬°PROYECTO LISTO PARA TESTING EN VIVO!');
    } else {
        console.log('\nüîß CORRECCIONES NECESARIAS ANTES DEL TESTING');
    }
    
}).catch(error => {
    console.error('‚ùå Error en auditor√≠a:', error);
});
