// =====================================================
// TEST: VERIFICACI√ìN WARNINGS SEARCH PATH SOLUCIONADOS
// =====================================================
// Fecha: 2025-01-27
// Prop√≥sito: Verificar que los warnings de search_path fueron corregidos
// Funciones: update_user_profile, validate_operation_type, handle_updated_at
// =====================================================

const { createClient } = require('@supabase/supabase-js');

// Configuraci√≥n de Supabase con credenciales actualizadas
const SUPABASE_URL = 'https://qfeyhaaxyemmnohqdele.supabase.co';
const SUPABASE_SERVICE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFmZXloYWF4eWVtbW5vaHFkZWxlIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NTgxNjczOCwiZXhwIjoyMDcxMzkyNzM4fQ.5wJb1p0Rmg1dVIayIT4wZO_seDXTIwhVa36CyEgK-yM';

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);

console.log('üß™ TEST: VERIFICACI√ìN WARNINGS SEARCH PATH SOLUCIONADOS');
console.log('='.repeat(60));
console.log('');

async function testWarningsSolucionados() {
    try {
        console.log('üìã PASO 1: Verificar conexi√≥n a Supabase...');
        
        // Test de conexi√≥n
        const { data: connectionTest, error: connectionError } = await supabase
            .from('users')
            .select('count')
            .limit(1);

        if (connectionError) {
            console.log('‚ùå Error de conexi√≥n:', connectionError.message);
            return;
        }
        
        console.log('‚úÖ Conexi√≥n exitosa a Supabase');
        console.log('');

        console.log('üìã PASO 2: Verificar funciones con search_path fijo...');
        console.log('');

        // Verificar que las funciones tienen search_path configurado
        const funcionesAVerificar = ['update_user_profile', 'validate_operation_type', 'handle_updated_at'];
        const resultadosVerificacion = [];

        for (const nombreFuncion of funcionesAVerificar) {
            try {
                console.log(`üîç Verificando funci√≥n: ${nombreFuncion}`);
                
                const { data: funcionInfo, error: funcionError } = await supabase
                    .rpc('sql', {
                        query: `
                            SELECT 
                                proname as function_name,
                                prosecdef as security_definer,
                                proconfig as config_settings,
                                CASE 
                                    WHEN proconfig IS NOT NULL AND 'search_path=public,pg_temp' = ANY(proconfig) 
                                    THEN true 
                                    ELSE false 
                                END as has_fixed_search_path
                            FROM pg_proc p
                            JOIN pg_namespace n ON p.pronamespace = n.oid
                            WHERE n.nspname = 'public' AND p.proname = '${nombreFuncion}';
                        `
                    });

                if (!funcionError && funcionInfo && funcionInfo.length > 0) {
                    const func = funcionInfo[0];
                    const status = func.has_fixed_search_path ? '‚úÖ CORREGIDO' : '‚ö†Ô∏è PENDIENTE';
                    console.log(`   ${status} ${func.function_name}`);
                    console.log(`      ‚îî‚îÄ Security Definer: ${func.security_definer}`);
                    console.log(`      ‚îî‚îÄ Search Path Fijo: ${func.has_fixed_search_path}`);
                    console.log(`      ‚îî‚îÄ Config: ${func.config_settings || 'No configurado'}`);
                    
                    resultadosVerificacion.push({
                        nombre: nombreFuncion,
                        existe: true,
                        searchPathFijo: func.has_fixed_search_path,
                        securityDefiner: func.security_definer
                    });
                } else {
                    console.log(`   ‚ùå NO ENCONTRADA ${nombreFuncion}`);
                    resultadosVerificacion.push({
                        nombre: nombreFuncion,
                        existe: false,
                        searchPathFijo: false,
                        securityDefiner: false
                    });
                }
                console.log('');
            } catch (error) {
                console.log(`   ‚ùå ERROR verificando ${nombreFuncion}:`, error.message);
                resultadosVerificacion.push({
                    nombre: nombreFuncion,
                    existe: false,
                    searchPathFijo: false,
                    error: error.message
                });
            }
        }

        console.log('üìã PASO 3: Test funcional de las funciones...');
        console.log('');

        // Test funci√≥n validate_operation_type
        try {
            console.log('üß™ Testing validate_operation_type...');
            
            const { data: testValid, error: testValidError } = await supabase
                .rpc('validate_operation_type', { operation_type: 'update' });

            const { data: testInvalid, error: testInvalidError } = await supabase
                .rpc('validate_operation_type', { operation_type: 'invalid' });

            if (!testValidError && !testInvalidError) {
                console.log(`   ‚úÖ validate_operation_type('update'): ${testValid}`);
                console.log(`   ‚úÖ validate_operation_type('invalid'): ${testInvalid}`);
            } else {
                console.log('   ‚ö†Ô∏è Error en test funcional:', testValidError?.message || testInvalidError?.message);
            }
        } catch (error) {
            console.log('   ‚ö†Ô∏è validate_operation_type no disponible para test');
        }

        console.log('');

        // Test funci√≥n update_user_profile (solo verificar que existe, no ejecutar)
        try {
            console.log('üß™ Testing update_user_profile (verificaci√≥n de existencia)...');
            
            const { data: funcExists, error: funcExistsError } = await supabase
                .rpc('sql', {
                    query: `
                        SELECT EXISTS(
                            SELECT 1 FROM pg_proc p
                            JOIN pg_namespace n ON p.pronamespace = n.oid
                            WHERE n.nspname = 'public' AND p.proname = 'update_user_profile'
                        ) as exists;
                    `
                });

            if (!funcExistsError && funcExists && funcExists[0]?.exists) {
                console.log('   ‚úÖ update_user_profile: EXISTE y disponible');
            } else {
                console.log('   ‚ö†Ô∏è update_user_profile: No encontrada');
            }
        } catch (error) {
            console.log('   ‚ö†Ô∏è Error verificando update_user_profile');
        }

        console.log('');

        // Test trigger handle_updated_at
        try {
            console.log('üß™ Testing trigger handle_updated_at...');
            
            const { data: triggerInfo, error: triggerError } = await supabase
                .rpc('sql', {
                    query: `
                        SELECT 
                            trigger_name, 
                            event_object_table, 
                            action_timing, 
                            event_manipulation
                        FROM information_schema.triggers 
                        WHERE trigger_schema = 'public' 
                        AND event_object_table = 'users'
                        AND action_statement LIKE '%handle_updated_at%';
                    `
                });

            if (!triggerError && triggerInfo && triggerInfo.length > 0) {
                console.log('   ‚úÖ Trigger handle_updated_at: ACTIVO');
                triggerInfo.forEach(trigger => {
                    console.log(`      ‚îî‚îÄ ${trigger.trigger_name} on ${trigger.event_object_table}`);
                    console.log(`      ‚îî‚îÄ ${trigger.action_timing} ${trigger.event_manipulation}`);
                });
            } else {
                console.log('   ‚ö†Ô∏è Trigger handle_updated_at: No encontrado');
            }
        } catch (error) {
            console.log('   ‚ö†Ô∏è Error verificando trigger handle_updated_at');
        }

        console.log('');
        console.log('üìä RESUMEN DE VERIFICACI√ìN:');
        console.log('='.repeat(40));

        const funcionesCorregidas = resultadosVerificacion.filter(f => f.existe && f.searchPathFijo).length;
        const funcionesExistentes = resultadosVerificacion.filter(f => f.existe).length;
        const funcionesTotales = resultadosVerificacion.length;

        console.log(`‚úÖ Funciones con search_path fijo: ${funcionesCorregidas}/${funcionesTotales}`);
        console.log(`üìã Funciones existentes: ${funcionesExistentes}/${funcionesTotales}`);
        console.log('');

        if (funcionesCorregidas === funcionesTotales) {
            console.log('üéâ ¬°TODOS LOS WARNINGS CORREGIDOS!');
            console.log('‚úÖ Todas las funciones tienen search_path fijo');
            console.log('‚úÖ Los warnings de seguridad est√°n solucionados');
        } else if (funcionesCorregidas > 0) {
            console.log('‚ö†Ô∏è CORRECCI√ìN PARCIAL');
            console.log(`‚úÖ ${funcionesCorregidas} funciones corregidas`);
            console.log(`‚ö†Ô∏è ${funcionesTotales - funcionesCorregidas} funciones pendientes`);
        } else {
            console.log('‚ùå WARNINGS NO CORREGIDOS');
            console.log('‚ö†Ô∏è Ninguna funci√≥n tiene search_path fijo');
            console.log('üîß Ejecutar script de soluci√≥n SQL');
        }

        console.log('');
        console.log('üéØ ESTADO FINAL:');
        resultadosVerificacion.forEach(func => {
            const status = func.existe ? 
                (func.searchPathFijo ? '‚úÖ CORREGIDO' : '‚ö†Ô∏è PENDIENTE') : 
                '‚ùå NO EXISTE';
            console.log(`   ${status} ${func.nombre}`);
        });

        console.log('');
        console.log('üìã PR√ìXIMOS PASOS:');
        if (funcionesCorregidas === funcionesTotales) {
            console.log('   ‚úÖ Warnings corregidos - No se requieren acciones');
            console.log('   üìä Verificar en Supabase Dashboard que warnings desaparecieron');
        } else {
            console.log('   üîß Ejecutar: Blackbox/solucion-warnings-search-path-definitiva.sql');
            console.log('   üìä Re-ejecutar este test despu√©s de aplicar la soluci√≥n');
        }

        // Guardar resultado del test
        const resultadoTest = {
            timestamp: new Date().toISOString(),
            funciones_verificadas: resultadosVerificacion,
            funciones_corregidas: funcionesCorregidas,
            funciones_totales: funcionesTotales,
            estado: funcionesCorregidas === funcionesTotales ? 'COMPLETADO' : 'PENDIENTE',
            warnings_solucionados: funcionesCorregidas === funcionesTotales
        };

        const fs = require('fs');
        fs.writeFileSync('Blackbox/test-warnings-resultado.json', JSON.stringify(resultadoTest, null, 2));

        console.log('');
        console.log('‚úÖ TEST COMPLETADO');
        console.log('üìÑ Resultado guardado en: Blackbox/test-warnings-resultado.json');

    } catch (error) {
        console.error('‚ùå Error en el test:', error);
    }
}

// Ejecutar test
testWarningsSolucionados();
